---
active_crumb: Data Model
layout: documentation
---

<!--
   “Commons Clause” License, https://commonsclause.com/

   The Software is provided to you by the Licensor under the License,
   as defined below, subject to the following condition.

   Without limiting other conditions in the License, the grant of rights
   under the License will not include, and the License does not grant to
   you, the right to Sell the Software.

   For purposes of the foregoing, “Sell” means practicing any or all of
   the rights granted to you under the License to provide to third parties,
   for a fee or other consideration (including without limitation fees for
   hosting or consulting/support services related to the Software), a
   product or service whose value derives, entirely or substantially, from
   the functionality of the Software. Any license notice or attribution
   required by the License must also include this Commons Clause License
   Condition notice.

   Software:    NLPCraft
   License:     Apache 2.0, https://www.apache.org/licenses/LICENSE-2.0
   Licensor:    Copyright (C) 2018 DataLingvo, Inc. https://www.datalingvo.com

       _   ____      ______           ______
      / | / / /___  / ____/________ _/ __/ /_
     /  |/ / / __ \/ /   / ___/ __ `/ /_/ __/
    / /|  / / /_/ / /___/ /  / /_/ / __/ /_
   /_/ |_/_/ .___/\____/_/   \__,_/_/  \__/
          /_/
-->

<div class="col-md-8 second-column">
    <section id="overview">
        <span class="section-title">Data Model Overview</span>
        <p>
            99% of what you do when using NLPCraft is developing a semantic data model for your own data endpoints
            like a database or a service.
        </p>
        <p>
            NLPCraft employs model-as-a-code approach where data model is simply an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>  interface that can be developed using any JVM programming
            language like Java, Scala, Kotlin, or Groovy. Generally, a data model implementation defines:
        </p>
        <ul>
            <li>
                How to interpret user input
            </li>
            <li>
                How to query or control a particular data source
            </li>
            <li>
                How to format the result back to the user
            </li>
        </ul>
        <p>
            Note that model-as-a-code approach natively supports any software life
            cycle tools and frameworks in Java eco-system like various build tools, CI/SCM tools, IDEs, etc.
            In other words, you don't have to use awkward web-based tools to manage some aspects of your
            models - your entire model is part of your project source code.
        </p>
    </section>
    <section id="lifecycle">
        <span class="section-title">Data Model Lifecycle</span>
        <p>
            Data model is an implementation of <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>
            interface. To create data model you can either:
        </p>
        <ul>
            <li>
                Implement <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface directly
            </li>
            <li>
                Use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCModelBuilder.html">NCModelBuilder</a>
                builder class which is a recommended way under the most circumstances.
            </li>
        </ul>
        <p>
            There are only two methods on <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>
            interface that you must provide implementation for - while all other methods have reasonable defaults:
        </p>
        <ul>
            <li><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getDescriptor--">getDescriptor()</a></li> - returning model identification.
            <li><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext)</a></li> - accepting parsed user input and returning result.
        </ul>
        <div class="bq info">
            <b>JSON <span class="amp">&amp;</span> YAML</b>
            <p>
                When using
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCModelBuilder.html">NCModelBuilder</a>
                model builder you can abstract most of the static model definition into an external JSON or YAML file -
                which is a recommended approach in most cases. See <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>
                interface for details.
            </p>
        </div>
        <p>
            To deploy a data model you need to provide an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> - a simple
            interface that acts as a factory or a builder for one or more
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> instances. This separation is
            important as it enables data probes to query data model provider about which models it supports
            without necessarily instantiating an actual data model which could be expensive, not idempotent
            and time-consuming operation.
        </p>
        <div class="bq info">
            <b>NCModelProviderAdapter</b>
            <p>
                Note that instead of implementing
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                directly in most cases you can use a
                convenient
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProviderAdapter.html">NCModelProviderAdapter</a> adapter class.
            </p>
        </div>
        <p>
            As described before the data models get <a href="/deploying-data-model.html">deployed</a> to and hosted by the data probes - a lightweight
            container whose job is to host data models and transfer requests between REST server and the data
            models. When a data probe starts it reads its configuration file <code>probe.conf</code> to see which models to
            deploy:
        </p>
        <ul>
            <li>
                If property <code>modelProviders</code> is defined the data probe will try to deploy all models
                this property defines by their fully qualified class names.
            </li>
            <li>
                If property <code>jarsFolder</code> is defined the data probe will recursively scan for all JAR files in this
                folder and will try to find all implementations of
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                and deploy their data models.
            </li>
        </ul>
        <p>
            Note that once deployed the data model is immutable. If you need to change the data model
            configuration or implementation, as in the development and testing phases,  you need to restart the
            probe to redeploy this data model.
        </p>
        <span class="section-sub-title">Lifecycle Events</span>
        <p>
            There are two data model lifecycle callbacks on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface
            that you can optionally override:
        </p>
        <ul>
            <li><code>initialize(NCProbeContext)</code> - called to initialize the model when it gets deployed.</li>
            <li><code>discard()</code> - called to discard the data model when data probe is shutting down.</li>
        </ul>
    </section>
    <section id="elements">
        <span class="section-title">Data Model Elements</span>
        <ul>
            <li><a href="#synonyms">Synonyms</a></li>
            <li><a href="#macros">Macros</a></li>
            <li><a href="#option-groups">Option Groups</a></li>
            <li><a href="#regex">Regular Expressions</a></li>
            <li><a href="#pos-tag">Point-of-Speech Tags</a></li>
            <li><a href="#values">Element Values</a></li>
            <li><a href="#groups">Element Groups</a></li>
        </ul>
        <p>
            One of the most important parts of developing a data model is defining its elements. A data model
            element is the main building block of the semantic data model. A semantic element defines an entity
            that will be automatically recognized as a token in the user input either by one of its synonyms or values or
            directly by its ID. These tokens in turn will be used by the data model in its matching logic.
        </p>
        <div class="bq info">
            <b>Named Entity Resolution <span class="amp">&amp;</span> Semantic Model</b>
            <p>
                An astute reader can notice the similarities between classic Named Entity Resolution (NER) and
                model elements. Indeed, both try to identify semantic categories rather than generic structural or
                linguistic categories.
            </p>
            <p>
                However, there is a number of important distinctions:
            </p>
            <ul>
                <li>
                    Most of the modern NER implementations employ a statistical machine learning (ML) approach and
                    therefore require substantial training corpora to create the ML models in the first place.  That
                    limits such implementations only to a very generic, well-understood categories like TIME,
                    DATE or PERSON for which well-defined corpora data exists.
                </li>
                <li>
                    Due to probabilistic nature of ML approach classic NER is often unreliable in a short-sentence,
                    command oriented interfaces.
                </li>
                <li>
                    Because of previous limitations standard NER is not suitable for domain-specific knowledge
                    areas where no large pre-existing data corpus exists.
                </li>
            </ul>
            <p>
                It's important to note that some NLP toolkits provide a variation of NER sometimes called a
                Normalized Named Entity Resolution (NNER) that is based on rule-based logic or semantic
                modeling. For example, DATE or CURRENCY named entities can be normalized by
                <a target=_ href="https://stanfordnlp.github.io/CoreNLP/ner.html">Stanford CoreNLP</a>
                toolkit (which is one of the base NLP engines that NLPCraft can be
                <a href="/download.html#optional">configured</a> with).
            </p>
            <p>
                Assuming a simplified  NER terminology, one could argue that Semantic Modeling allows you to build
                your own <b>reliable named entity resolver</b> specific to your own domain area.
            </p>
        </div>
        <p>
            Data model element is defined by <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a>
            interface.
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> defines
            its elements via <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getElements--">getElements()</a> method. To create model element
            you can either:
        </p>
        <ul>
            <li>
                Implement <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> interface directly
            </li>
            <li>
                Use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCElementBuilder.html">NCElementBuilder</a>
                builder class if element definition is constructed dynamically
            </li>
            <li>
                Use JSON or YAML static model configuration (the preferred way in most cases)
            </li>
        </ul>
        <p>
            When defining the elements the synonyms play the most critical role. It is the synonyms that define
            how a particular element will be detected in the user input. While adding synonyms sounds rather
            trivial - in real models, this may become a daunting and time-consuming task. It is not uncommon
            for a particular model element to have thousands and even tens of thousands of possible synonyms
            due to words, grammar, and linguistic permutations.
        </p>
        <p>
            NLPCraft provides effective support for a compact synonyms representation. Instead of listing all possible
            multi-word synonyms one by one you can use <a href="#macros">macros</a>,
            <a href="#option-groups">option groups</a>, <a href="#regex">regular expressions</a>,
            and <a href="#pos-tag">PoS tags</a> to significantly shorten that list.
        </p>
        <span id="synonyms" class="section-sub-title">Synonyms</span>
        <p>
            Synonyms are the key building blocks of the data model element and used in the following
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> methods:
        </p>
        <ul>
            <li><code>getSynonyms()</code> - gets synonyms to match on.</li>
            <li><code>getExcludedSynonyms()</code> - gets synonyms to exclude.</li>
            <li><code>getValues()</code> - get values to match on.</li>
        </ul>
        <p>
            Each data model element has one or more synonyms. Note that element ID is its implicit synonym so that
            even if no additional synonyms are defined at least one synonym always exists. Each individual synonym
            is a whitespace separated combination of:
        </p>
        <ul>
           <li>simple word,</li>
           <li>regular expression, or</li>
           <li>PoS tag</li>
        </ul>
        <p>
            Note that synonym matching for simple words is case insensitive and automatically
            performed on <b>normalized and stemmatized forms</b> of such word and therefore the model
            developer doesn't have to account for this in the synonyms themselves.
        </p>
        <span id="macros" class="section-sub-title">Macros</span>
        <p>
            Listing all possible multi-word synonyms for a given element can be a time-consuming task. Macros
            together with option groups allow for significant simplification of this process.
            Macros let you give a name to an often used set of words or option groups and reuse it without
            repeating those words or option groups again and again. A model provides a list of macros via
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getMacros--">getMacros()</a> method on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface. Each macro
            has a name in a form of <code>&lt;X&gt;</code> where <code>X</code>
            is just any string, and a string value. Note that macros can be nested, i.e. macro value can include
            references to other macros. When macro name <code>X</code> is encountered in the synonym it gets recursively
            replaced with its value.
        </p>
        <p>
            Here's a code snippet of macro definitions using JSON definition:
        </p>
        <pre class="brush: js">
            "macros": [
                {
                    "name": "&lt;A&gt;",
                    "macro": "aaa"
                },
                {
                    "name": "&lt;B&gt;",
                    "macro": "&lt;A&gt; bbb"
                },
                {
                    "name": "&lt;C&gt;",
                    "macro": "&lt;A&gt; bbb {z|w}"
                }
             ]
        </pre>
        <span id="option-groups" class="section-sub-title">Option Groups</span>
        <p>
           Option groups are a simplified form of regular expressions that operates on a single word base. The
           following examples demonstrate how to use option groups.
        </p>
        <p>
            Consider the following macros defined below (note that macros <code>&lt;B&gt;</code> and <code>&lt;C&gt;</code>
            are nested):
        </p>
        <table class="gradient-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>&lt;A&gt;</code></td>
                    <td><code>aaa</code></td>
                </tr>
                <tr>
                    <td><code>&lt;B&gt;</code></td>
                    <td><code>&lt;A&gt; bbb</code></td>
                </tr>
                <tr>
                    <td><code>&lt;C&gt;</code></td>
                    <td><code>&lt;A&gt; bbb {z|w}</code></td>
                </tr>
            </tbody>
        </table>
        <p>
            Then the following option group expansions will occur in these examples:
        </p>
        <table class="gradient-table">
            <thead>
               <tr>
                   <th>Synonym</th>
                   <th>Expanded Synonyms</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                   <td><code>&lt;A&gt; {b|*} c</code></td>
                   <td>
                       <code>"aaa b c"</code><br>
                       <code>"aaa c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>&lt;B&gt; {b|*} c</code></td>
                   <td>
                       <code>"aaa bbb b c"</code><br>
                        <code>"aaa bbb c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{b|```NN```} c</code></td>
                   <td>
                       <code>"b c"</code><br>
                       <code>"```NN``` c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{b|\{\*\}}</code></td>
                   <td>
                       <code>"b"</code><br>
                       <code>"b {*}"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a {b|*}. c</code></td>
                   <td>
                       <code>"a b. c"</code><br>
                       <code>"a . c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a .{b,  |*}. c</code></td>
                   <td>
                       <code>"a .b, . c"</code><br>
                       <code>"a .. c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>
                       {% raw %}a {{b|c}|*}.{% endraw %}</code></td>
                   <td>
                       <code>"a ."</code><br>
                       <code>"a b."</code><br>
                       <code>"a c."</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a {% raw %}{{{&lt;C&gt;}}|{*}}{% endraw %} c</code></td>
                   <td>
                       <code>"a aaa bbb z c"</code><br>
                       <code>"a aaa bbb w c"</code><br>
                       <code>"a c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{% raw %}{{{a}}} {b||*|{{*}}||*}{% endraw %}</code></td>
                   <td>
                       <code>"a b"</code><br>
                       <code>"a"</code>
                   </td>
               </tr>
            </tbody>
        </table>
        <p>
           Specifically:
        </p>
        <ul>
            <li><code>{A|B}</code>  denotes either <code>A</code> or <code>B</code>.</li>
            <li><code>{A|B|*}</code>  denotes either <code>A</code> or <code>B</code> or nothing.</li>
            <li>Excessive curly brackets are ignored, when safe to do so.</li>
            <li>Macros cannot be recursive but can be nested.</li>
            <li>Option groups can be nested.</li>
            <li>
                <code>'\'</code> (backslash) can be used to escape <code>'{'</code>, <code>'}'</code>, <code>'|'</code> and
                <code>'*'</code> special symbols used by the option groups.
            </li>
            <li>Excessive whitespaces are trimmed when expanding option groups.</li>
        </ul>
        <span id="regex" class="section-sub-title">Regular Expressions</span>
        <p>
            Any individual synonym word that starts and ends with <code>///</code> (three forward slashes) is
            considered to be Java regular expression as defined in <code>java.util.regex.Pattern</code>. Note that
            regular expression can only span a single word, i.e. only individual words from the user input will be
            matched against given regular expression and no whitespaces are allowed within regular expression. Note
            also that option group special symbols <code>{</code>, <code>}</code>,
            <code>|</code> and <code>*</code> have to be escaped in the regular expression using <code>\</code>
            (backslash).
        </p>
        <p>
            For example, the following synonym <code>{foo|///[bar].+///}}</code> will match word <code>foo</code>
            or any other strings that start with <code>bar</code> as long as this string doesn't contain whitespaces.
        </p>
        <div class="bq info">
            <b>Regular Expressions Performance</b>
            <p>
                It's important to note that regular expressions can significantly affect the performance of the
                underlying NLPCraft implementation if used uncontrolled. Use it with caution and test the performance
                of your model to ensure it meets your expectations.
            </p>
        </div>
        <span id="pos-tag" class="section-sub-title">Part-of-Speech Tags</span>
        <p>
            Any individual synonym word that that starts and ends with <code>```</code> (three back ticks) in a
            form <code>```XXX```</code> is
            considered to be a PoS (Part-of-Speech) tag that will be matched against PoS tag of the individual word in the
            user input, where <code>XXX</code> is one of the
            <a target=_ href="https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html">Penn Treebank PoS</a> tags.
        </p>
        <p>
            For example, the following synonym <code>{foo|{```NN```|```NNS```|```NNP```|```NNPS```}}</code> will
            match word <code>foo</code> or any form of a noun.
        </p>
        <span id="values" class="section-sub-title">Element Values</span>
        <p>
            Model element can have an optional set of special synonyms called <em>values</em>. Unlike basic synonyms,
            each value is a pair of a name and a set of standard synonyms by which that value, and ultimately
            its element, can be recognized in the user input. Note that the value name itself acts as an
            implicit synonym even when no additional synonyms added for that value.
        </p>
        <p>
            When a model element is recognized it is made available to the model's matching logic as an instance of
            the <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interface.
            This interface has a method
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html#getValue--">getValue()</a> which
            returns the name of the value, if any, by which
            that model element was recognized. That value name can be further used in model matching logic or intents.
        </p>
        <p>
            To understand the importance of the values consider the following example. Imagine the model
            element <code>x:car</code> that tries to describe a car. It could have:
        </p>
        <ul>
            <li>
            Set of general synonyms encoded as:
            <code>{transportation|transport|*} {vehicle|car|sedan|auto|automobile|suv|crossover|coupe|truck}</code>
            </li>
            <li>Set of values:
                <ul>
                    <li><code>mercedes</code> with synonyms <code>mercedes-benz, mb, benz</code></li>
                    <li><code>bmw</code> with synonyms <code>bimmer</code></li>
                    <li><code>chevrolet</code> with synonyms <code>chevy</code></li>
                </ul>
            </li>
        </ul>
        With that setup <code>x:car</code> element will be recognized by any of the following input string:
        <ul>
            <li><code>transport car</code></li>
            <li><code>benz</code> (with value <code>mercedes</code>)</li>
            <li><code>automobile</code></li>
            <li><code>transport vehicle</code></li>
            <li><code>sedan</code></li>
            <li><code>chevy</code> (with value <code>chevrolet</code>)</li>
            <li><code>bimmer</code> (with value <code>bmw</code>)</li>
            <li><code>x:car</code></li>
        </ul>
        <span id="groups" class="section-sub-title">Element Groups</span>
        <p>
            Each model element belongs to a certain group. By default, all model elements belong to a single
            (default) group. However, the proper organization of the elements into groups can be an important mechanism
            in implementing model's <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext)</a> method.
        </p>
        <p>
            More specifically, the proper grouping of the elements is necessary for the correct operation of
            Short-Term-Memory (STM) in the conversational context when using intent-based matching.
        </p>
        <p>
            Consider a <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> that 
            represents a previously found model element that is stored in the conversation context. Such token
            will be overridden in the conversation context by the more <b>recent token</b>
            from the <b>same group</b> - a critical rule of maintaining the proper conversational context.
            In other words, the tokens (and their elements) with the same group can be overridden.
        </p>
    </section>
    <section id="metadata">
        <span class="section-title">Metadata</span>
        <p>
            Both <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> and
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interfaces have
            method <code>getMetadata()</code> that return user-defined metadata
            (a map-based container) that you can optionally attach to the data model and its elements. At runtime,
            the same metadata is available in <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> and
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interfaces (the latter one representing a
            matched <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a>).
        </p>
        <p>
            Metadata provides flexibility to attach any user-defined information to both model and its elements
            that is not supported by default in their respective interfaces. This allows providing extra configuration
            to how the model interprets the user input and prepares the answer.
        </p>
    </section>
    <section id="logic">
        <span class="section-title">Data Model Logic</span>
        <p>
            When a user sends its request via REST API it is received by the REST server. Upon receipt,
            the REST server does the basic NLP processing and enriching. Once finished, the REST server
            sends the enriched request down to a specific data probe selected based on the requested data model.
        </p>
        <p>
            When the data probe receives the enriched request from the REST server it performs the final
            pre-processing by detecting data model elements in the user text. When finished the data probe calls
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext ctx)</a> method on <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> instance
            passing it a fully parsed and enriched user request.
        </p>
        <p>
            At this point, the <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext ctx)</a> method must "understand" the user request and return the result
            that is sent back to the original REST API caller. Implementing this method is what typically amounts to over 90% of
            the overall development of the data model.
        </p>
        <span class="section-sub-title">Method <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext ctx)</a></span>
        <p>
            Here's the most simplest implementation of the <code>query(...)</code> method:
        </p>
        <pre class="brush: java">
            @Override
            public NCQueryResult query(NCQueryContext ctx) throws NCRejection {
                return NCQueryResult.text("no-op");
            }
        </pre>
        Comments:
        <ul>
            <li>This implementation return <code>"no-op"</code> text back for any user input.</li>
            <li>
                This is obviously pretty useless but it demonstrates how simple the implementation can be in the extreme case.
            </li>
            <li>
                Notice how we use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCQueryResult.html">NCQueryResult</a>
                class to create result. This class supports various types of results like <code>json, yaml, text,</code>
                and <code>html</code> and we will be using this class in all our examples.
            </li>
        </ul>
        <span class="section-sub-title">Interface <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCQueryContext.html">NCQueryContext</a></span>
        <p>
            You noticed that <code>query(...)</code> method accepts the instance of <code>NCQueryContext</code> interface as
            its parameter. This interface provides all available data about the parsed user input and all its supplemental information.
        </p>
        <p>
            Review <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCQueryContext.html">NCQueryContext</a>
            interface Javadoc as it a provides large amount of information to the <code>query(...)</code> method:
        </p>
        <ul>
            <li>
                Server request ID. Server request is defined as a processing of one user input sentence.
            </li>
            <li>
                Reference to <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCConversationContext.html">NCConversationContext</a>
                for controlling STM of conversation manager.
            </li>
            <li>
                Reference to <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCDataSource.html">NCDataSource</a>
                describing the data source that was used to submit user request with.
            </li>
            <li>
                Reference to <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> that the
                <code>query(...)</code> method belongs to.
            </li>
            <li>
                Reference to <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">NCSentence</a> that
                provides parsing information for the user input.
            </li>
        </ul>
        <div class="bq info">
            <b>NCProbeContext</b>
            <p>
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCProbeContext.html">NCProbeContext</a>
                interface provides information about data probe that the current model is hosted in. It provides
                data probe endpoints, ID of the probe and probe's secure token. 
            </p>
            <p>
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCProbeContext.html">NCProbeContext</a> reference
                is passed to data model's
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#initialize-org.nlpcraft.model.NCProbeContext-">initialze(...)</a> method.
                The default implementation of this method simply stores the probe context in model's metadata from which
                it can be accessed by the <code>query(...)</code> method.
            </p>
        </div>
        <p>
            Out of all this information the <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">NCSentence</a>
            interface is the most important to review in details.
        </p>
        <span class="section-sub-title">Interface <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">NCSentence</a></span>
        <p>
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">NCSentence</a> interface
            is one of the main entities in Data Model API that you as a model developer will be working with. You
            should review its <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">Javadoc</a> but
            here is an outline of the information it provides:
        </p>
        <ul>
            <li>
                Information about the user that issued the request.
            </li>
            <li>
                User agent and remote address, if any available, of the user's application that made the initial REST call.
            </li>
            <li>
                Original request text, timestamp of its receipt, and server request ID.
            </li>
            <li>
                One or more parsed variants of the original text.
            </li>
        </ul>
        <p>
            All the information in the <code>NCSentence</code> interface can be valuable for a specific
            <code>query(...)</code> method implementation. However, it is the list of
            parsing <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCVariant.html">variants</a> provided
            by <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html#getVariants--">List&lt;NCVariant&gt; getVariants()</a>
            method that provides the most valuable information for the "understanding" of the user input.
        </p>
        <span class="section-sub-title">Interface <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCVariant.html">NCVariant</a></span>
        <p>
            When the user sentence gets parsed into individual tokens (i.e. semantic elements) there is generally
            more than one way to do it. This ambiguity is perfectly fine because only the data model has all the
            necessary information to select one parsing variant that fits that model the best. Without the data model
            there isn't enough context to determine which variant is the best fitting.
        </p>
        <p>
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCVariant.html">NCVariant</a> interface is a
            list of <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> object, and
            it represents one possible parsing variant. Note
            that <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCVariant.html">NCVariant</a> interface
            supports natural order from best to worst.
        </p>
        <p>
            Method <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html#getVariants--">List&lt;NCVariant&gt; getVariants()</a> on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCSentence.html">NCSentence</a> returns list of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCVariant.html">variants</a> for a given user input.
            Method <code>query(...)</code> should generally analyse all given parsing variants in determining the
            meaning of the user sentence.
        </p>
        <div class="bq info">
            <b><a target="javadoc" href="/apis/latest/org/nlpcraft/model/intent/NCIntentSolver.html">NCIntentSolver</a></b>
            <p>
                Intent-matcher <a target="javadoc" href="/apis/latest/org/nlpcraft/model/intent/NCIntentSolver.html">NCIntentSolver</a></b>
                automatically checks all variants, from best to worst, when trying to find a match for a given intent.
            </p>
        </div>
        <span class="section-sub-title">Interface <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a></span>
        <p>
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> object is another
            key abstraction in Data Model API. A token is a part of a fully parsed user input. Sequence of tokens
            represents parsed user input.
            A single token corresponds to a one or more original normalized words, sequential or not, in the
            user sentence and can be of two types:
        </p>
        <ul>
            <li>
                <b>System defined</b> token that represents a built-in element whose ID starts with <code>nlp:</code>,
                e.g. <code>nlp:num</code>, <code>nlp:geo</code>.
            </li>
            <li>
                <b>User defined</b> token that represent one of the data model's elements detected in the user
                input (see <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getElements--">NCModel.getElements()</a> method).
            </li>
        </ul>
        <p>
            Most of the token's information is stored in map-like metadata accessible via <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html#getMetadata--">getMetadata()</a> method.
            Depending on the ID of the token metadata will contain different properties. Some properties are common
            across all tokens. Consult <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html#getMetadata--">getMetadata()</a> method
            for detailed explanation. Note that class <a target="javadoc" href="/apis/latest/org/nlpcraft/model/utils/NCTokenUtils.html">NCTokenUtils</a>
            provides utility accessors to all metadata properties returned by <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html#getMetadata--">getMetadata()</a> method in a convenient
            type-safe way.
        </p>
        <span class="section-sub-title">System Built-In Elements</span>
        <p>
            Additionally to the user defined model element - the ones you actually define in your model elements -
            NLPCraft provides number of system or built-in elements that are detected <b>automatically</b> in the
            user input. You don't have to explicitly define them or provide synonyms for them - you can simply
            use them in your logic or intents as if they were defined already.
        </p>
        <p>
            Here's the list of all built-in elements:
        </p>
        <!--
        "nlp:nlp",
        "nlp:geo",
        "nlp:date",
        "nlp:num",
        "nlp:function",
        "nlp:coordinate"
        -->
        <table class="gradient-table">
            <thead>
            <tr>
                <th>Element ID</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code><nobr>nlp:geo</nobr></code></a></td>
                <td>Geographical location (continents, country, region, city or metro area).</td>
                <td>
                    <code>London</code><br>
                    <code>California</code><br>
                    <code>Palo Alto, CA</code><br>
                    <code>USA</code>
                </td>
            </tr>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code><nobr>nlp:coordinate</nobr></code></a></td>
                <td>Latitude and longitude coordinates.</td>
                <td>
                    <code>41.25 and -120.9762</code>
                </td>
            </tr>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code><nobr>nlp:date</nobr></code></a></td>
                <td>Date and time range.</td>
                <td>
                    <code>June 27, 2016</code><br>
                    <code>Last week</code><br>
                    <code>From 3/4/2016 to today</code>
                </td>
            </tr>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code><nobr>nlp:num</nobr></code></a></td>
                <td>Numeric, units and numeric conditional expression.</td>
                <td>
                    <code>less than or equal to 50</code><br>
                    <code>&gt;= 5</code><br>
                    <code>5 ms</code><br>
                    <code>equal to 10 cm</code>
                </td>
            </tr>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code>nlp:function</code></a></td>
                <td>
                    One of the supported functions:
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>MAX</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>MIN</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>SUM</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>SORT</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>LIMIT</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>AVG</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>GROUP</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>CORRELATION</code></a>,
                    <a target="javadoc" href="https://www.datalingvo.com/client/src/javadoc/com/datalingvo/mdllib/DLToken.html#getMetadata--"><code>COMPARE</code></a>.
                </td>
                <td>
                    <code>correlation between date of close and deal size</code><br>
                    <code>sort descending by product</code><br>
                    <code>top 5 items</code>
                </td>
            </tr>
            <tr>
                <td><a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html"><code>nlp:nlp</code></a></td>
                <td>Neither user defined nor any of the above ones.</td>
                <td>
                </td>
            </tr>
            </tbody>
        </table>
    </section>
</div>
<div class="col-md-2 third-column">
    <ul class="side-nav">
        <li class="side-nav-title">On This Page</li>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#lifecycle">Lifecycle</a></li>
        <li><a href="#elements">Elements</a></li>
        <li><a href="#metadata">Metadata</a></li>
        <li><a href="#logic">Logic</a></li>
        <li class="side-nav-title">Quick Links</li>
        <li>
            <img class="quick-link-img mr-2" src="/images/github_logo.png"><a
            target="github"
            href="https://github.com/vic64/nlpcraft/tree/master/src/main/scala/org/nlpcraft/examples">Examples</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/java.png"><a
            target="javadoc"
            href="/apis/latest/index.html">Javadoc</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/apiary.svg"><a
            href="https://nlpcraft.docs.apiary.io"
            target="apiary">REST API</a>
        </li>
        <li>
            <i class="fas fa-download mr-2"></i><a href="/download">Download</a>
        </li>
        <li class="side-nav-title">Support</li>
        <li>
            <nobr>
                <i class="far fa-fw fa-envelope mr-2"></i><a href="mailto:support@nlpcraft.org">Email</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-stack-overflow mr-2"></i><a target="so" href="https://stackoverflow.com/questions/ask">Stack Overflow</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-github mr-2"></i><a target="github" href="https://github.com/vic64/nlpcraft/issues">GitHub</a>
            </nobr>
        </li>
    </ul>
</div>




