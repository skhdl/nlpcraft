---
active_crumb: Data Model API
layout: documentation
---

<!--
   “Commons Clause” License, https://commonsclause.com/

   The Software is provided to you by the Licensor under the License,
   as defined below, subject to the following condition.

   Without limiting other conditions in the License, the grant of rights
   under the License will not include, and the License does not grant to
   you, the right to Sell the Software.

   For purposes of the foregoing, “Sell” means practicing any or all of
   the rights granted to you under the License to provide to third parties,
   for a fee or other consideration (including without limitation fees for
   hosting or consulting/support services related to the Software), a
   product or service whose value derives, entirely or substantially, from
   the functionality of the Software. Any license notice or attribution
   required by the License must also include this Commons Clause License
   Condition notice.

   Software:    NLPCraft
   License:     Apache 2.0, https://www.apache.org/licenses/LICENSE-2.0
   Licensor:    Copyright (C) 2018 DataLingvo, Inc. https://www.datalingvo.com

       _   ____      ______           ______
      / | / / /___  / ____/________ _/ __/ /_
     /  |/ / / __ \/ /   / ___/ __ `/ /_/ __/
    / /|  / / /_/ / /___/ /  / /_/ / __/ /_
   /_/ |_/_/ .___/\____/_/   \__,_/_/  \__/
          /_/
-->

<div class="col-md-8 second-column">
    <section id="overview">
        <span class="section-title">Data Model Overview</span>
        <p>
            99% of what you do when using NLPCraft is developing a semantic data model for your own data endpoints
            like a database or a service.
        </p>
        <p>
            NLPCraft employs model-as-a-code approach where data model is simply an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>  interface that can be developed using any JVM programming
            language like Java, Scala, Kotlin, or Groovy. Generally, a data model implementation defines:
        </p>
        <ul>
            <li>
                How to interpret user input
            </li>
            <li>
                How to query or control a particular data source
            </li>
            <li>
                How to format the result back to the user
            </li>
        </ul>
        <p>
            Note that model-as-a-code approach natively supports any software life
            cycle tools and frameworks in Java eco-system like various build tools, CI/SCM tools, IDEs, etc.
            In other words, you don't have to use awkward web-based tools to manage some aspects of your
            models - your entire model is part of your project source code.
        </p>
    </section>
    <section id="lifecycle">
        <span class="section-title">Data Model Lifecycle</span>
        <p>
            Data model is an implementation of <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a>
            interface. To create data model you can either:
        </p>
        <ul>
            <li>
                Implement <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface directly
            </li>
            <li>
                Use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCModelBuilder.html">NCModelBuilder</a>
                builder class which is a recommended way under the most circumstances.
            </li>
        </ul>
        <div class="bq info">
            <b>JSON <span class="amp">&amp;</span> YAML</b>
            <p>
                When using
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCModelBuilder.html">NCModelBuilder</a>
                model builder you can abstract most of the static model definition into an external JSON or YAML file -
                which is a recommended approach in most cases. 
            </p>
        </div>
        <p>
            To deploy a data model you need to provide an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> - a simple
            interface that acts as a factory or a builder for one or more
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> instances. This separation is
            important as it enables data probes to query data model provider about which models it supports
            without necessarily instantiating an actual data model which could be expensive, not idempotent
            and time-consuming operation.
        </p>
        <div class="bq info">
            <b>NCModelProviderAdapter</b>
            <p>
                Note that instead of implementing
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                directly in most cases you can use a
                convenient
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProviderAdapter.html">NCModelProviderAdapter</a> adapter class.
            </p>
        </div>
        <p>
            As described before the data models get <a href="/deploying-data-model.html">deployed</a> to and hosted by the data probes - a lightweight
            container whose job is to host data models and transfer requests between REST server and the data
            models. When a data probe starts it reads its configuration file <code>probe.conf</code> to see which models to
            deploy:
        </p>
        <ul>
            <li>
                If property <code>modelProviders</code> is defined the data probe will try to deploy all models
                this property defines by their fully qualified class names.
            </li>
            <li>
                If property <code>jarsFolder</code> is defined the data probe will recursively scan for all JAR files in this
                folder and will try to find all implementations of
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                and deploy their data models.
            </li>
        </ul>
        <p>
            Note that once deployed the data model is immutable. If you need to change the data model
            configuration or implementation, as in the development and testing phases,  you need to restart the
            probe to redeploy this data model.
        </p>
        <span class="section-sub-title">Lifecycle Events</span>
        <p>
            There are two data model lifecycle callbacks on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface
            that you can optionally override:
        </p>
        <ul>
            <li><code>initialize(NCProbeContext)</code> - called to initialize the model when it gets deployed.</li>
            <li><code>discard()</code> - called to discard the data model when data probe is shutting down.</li>
        </ul>
    </section>
    <section id="elements">
        <span class="section-title">Data Model Elements</span>
        <ul>
            <li><a href="#synonyms">Synonyms</a></li>
            <li><a href="#macros">Macros</a></li>
            <li><a href="#option-groups">Option Groups</a></li>
            <li><a href="#regex">Regular Expressions</a></li>
            <li><a href="#pos-tag">Point-of-Speech Tags</a></li>
            <li><a href="#values">Element Values</a></li>
            <li><a href="#groups">Element Groups</a></li>
        </ul>
        <p>
            One of the most important parts of developing a data model is defining its elements. A data model
            element is the main building block of the semantic data model. A semantic element defines an entity
            that will be automatically recognized as a token in the user input either by one of its synonyms or values or
            directly by its ID. These tokens in turn will be used by the data model in its matching logic.
        </p>
        <div class="bq info">
            <b>Named Entity Resolution <span class="amp">&amp;</span> Semantic Model</b>
            <p>
                An astute reader can notice the similarities between classic Named Entity Resolution (NER) and
                model elements. Indeed, both try to identify semantic categories rather than generic structural or
                linguistic categories.
            </p>
            <p>
                However, there is a number of important distinctions:
            </p>
            <ul>
                <li>
                    Most of the modern NER implementations employ a statistical machine learning (ML) approach and
                    therefore require substantial training corpora to create the ML models in the first place.  That
                    limits such implementations only to a very generic, well-understood categories like TIME,
                    DATE or PERSON for which well-defined corpora data exists.
                </li>
                <li>
                    Due to probabilistic nature of ML approach classic NER is often unreliable in a short-sentence,
                    command oriented interfaces.
                </li>
                <li>
                    Because of previous limitations standard NER is not suitable for domain-specific knowledge
                    areas where no large pre-existing data corpus exists.
                </li>
            </ul>
            <p>
                It's important to note that some NLP toolkits provide a variation of NER sometimes called a
                Normalized Named Entity Resolution (NNER) that is based on rule-based logic or semantic
                modeling. For example, DATE or CURRENCY named entities can be normalized by
                <a target=_ href="https://stanfordnlp.github.io/CoreNLP/ner.html">Stanford CoreNLP</a>
                toolkit (which is one of the base NLP engines that NLPCraft can be
                <a href="/download.html#optional">configured</a> with).
            </p>
            <p>
                Assuming a simplified  NER terminology, one could argue that Semantic Modeling allows you to build
                your own <b>reliable named entity resolver</b> specific to your own domain area.
            </p>
        </div>
        <p>
            Data model element is defined by <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a>
            interface.
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> defines
            its elements via <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getElements--">getElements()</a> method. To create model element
            you can either:
        </p>
        <ul>
            <li>
                Implement <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> interface directly
            </li>
            <li>
                Use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCElementBuilder.html">NCElementBuilder</a>
                builder class if element definition is constructed dynamically
            </li>
            <li>
                Use JSON or YAML static model configuration (the preferred way in most cases)
            </li>
        </ul>
        <p>
            When defining the elements the synonyms play the most critical role. It is the synonyms that define
            how a particular element will be detected in the user input. While adding synonyms sounds rather
            trivial - in real models, this may become a daunting and time-consuming task. It is not uncommon
            for a particular model element to have thousands and even tens of thousands of possible synonyms
            due to words, grammar, and linguistic permutations.
        </p>
        <p>
            NLPCraft provides effective support for a compact synonyms representation. Instead of listing all possible
            multi-word synonyms one by one you can use <a href="#macros">macros</a>,
            <a href="#option-groups">option groups</a>, <a href="#regex">regular expressions</a>,
            and <a href="#pos-tag">PoS tags</a> to significantly shorten that list.
        </p>
        <span id="synonyms" class="section-sub-title">Synonyms</span>
        <p>
            Synonyms are the key building blocks of the data model element and used in the following
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> methods:
        </p>
        <ul>
            <li><code>getSynonyms()</code> - gets synonyms to match on.</li>
            <li><code>getExcludedSynonyms()</code> - gets synonyms to exclude.</li>
            <li><code>getValues()</code> - get values to match on.</li>
        </ul>
        <p>
            Each data model element has one or more synonyms. Note that element ID is its implicit synonym so that
            even if no additional synonyms are defined at least one synonym always exists. Each individual synonym
            is a whitespace separated combination of:
        </p>
        <ul>
           <li>simple word,</li>
           <li>regular expression, or</li>
           <li>PoS tag</li>
        </ul>
        <p>
            Note that synonym matching for simple words is case insensitive and automatically
            performed on <b>normalized and stemmatized forms</b> of such word and therefore the model
            developer doesn't have to account for this in the synonyms themselves.
        </p>
        <span id="macros" class="section-sub-title">Macros</span>
        <p>
            Listing all possible multi-word synonyms for a given element can be a time-consuming task. Macros
            together with option groups allow for significant simplification of this process.
            Macros let you give a name to an often used set of words or option groups and reuse it without
            repeating those words or option groups again and again. A model provides a list of macros via
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getMacros--">getMacros()</a> method on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface. Each macro
            has a name in a form of <code>&lt;X&gt;</code> where <code>X</code>
            is just any string, and a string value. Note that macros can be nested, i.e. macro value can include
            references to other macros. When macro name <code>X</code> is encountered in the synonym it gets recursively
            replaced with its value.
        </p>
        <p>
            Here's a code snippet of macro definitions using JSON definition:
        </p>
        <pre class="brush: js">
            "macros": [
                {
                    "name": "&lt;A&gt;",
                    "macro": "aaa"
                },
                {
                    "name": "&lt;B&gt;",
                    "macro": "&lt;A&gt; bbb"
                },
                {
                    "name": "&lt;C&gt;",
                    "macro": "&lt;A&gt; bbb {z|w}"
                }
             ]
        </pre>
        <span id="option-groups" class="section-sub-title">Option Groups</span>
        <p>
           Option groups are a simplified form of regular expressions that operates on a single word base. The
           following examples demonstrate how to use option groups.
        </p>
        <p>
            Consider the following macros defined below (note that macros <code>&lt;B&gt;</code> and <code>&lt;C&gt;</code>
            are nested):
        </p>
        <table class="gradient-table">
            <thead>
                <tr>
                    <th>Name</th>
                    <th>Value</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>&lt;A&gt;</code></td>
                    <td><code>aaa</code></td>
                </tr>
                <tr>
                    <td><code>&lt;B&gt;</code></td>
                    <td><code>&lt;A&gt; bbb</code></td>
                </tr>
                <tr>
                    <td><code>&lt;C&gt;</code></td>
                    <td><code>&lt;A&gt; bbb {z|w}</code></td>
                </tr>
            </tbody>
        </table>
        <p>
            Then the following option group expansions will occur in these examples:
        </p>
        <table class="gradient-table">
            <thead>
               <tr>
                   <th>Synonym</th>
                   <th>Expanded Synonyms</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                   <td><code>&lt;A&gt; {b|*} c</code></td>
                   <td>
                       <code>"aaa b c"</code><br>
                       <code>"aaa c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>&lt;B&gt; {b|*} c</code></td>
                   <td>
                       <code>"aaa bbb b c"</code><br>
                        <code>"aaa bbb c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{b|```NN```} c</code></td>
                   <td>
                       <code>"b c"</code><br>
                       <code>"```NN``` c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{b|\{\*\}}</code></td>
                   <td>
                       <code>"b"</code><br>
                       <code>"b {*}"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a {b|*}. c</code></td>
                   <td>
                       <code>"a b. c"</code><br>
                       <code>"a . c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a .{b,  |*}. c</code></td>
                   <td>
                       <code>"a .b, . c"</code><br>
                       <code>"a .. c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>
                       {% raw %}a {{b|c}|*}.{% endraw %}</code></td>
                   <td>
                       <code>"a ."</code><br>
                       <code>"a b."</code><br>
                       <code>"a c."</code>
                   </td>
               </tr>
               <tr>
                   <td><code>a {% raw %}{{{&lt;C&gt;}}|{*}}{% endraw %} c</code></td>
                   <td>
                       <code>"a aaa bbb z c"</code><br>
                       <code>"a aaa bbb w c"</code><br>
                       <code>"a c"</code>
                   </td>
               </tr>
               <tr>
                   <td><code>{% raw %}{{{a}}} {b||*|{{*}}||*}{% endraw %}</code></td>
                   <td>
                       <code>"a b"</code><br>
                       <code>"a"</code>
                   </td>
               </tr>
            </tbody>
        </table>
        <p>
           Specifically:
        </p>
        <ul>
            <li><code>{A|B}</code>  denotes either <code>A</code> or <code>B</code>.</li>
            <li><code>{A|B|*}</code>  denotes either <code>A</code> or <code>B</code> or nothing.</li>
            <li>Excessive curly brackets are ignored, when safe to do so.</li>
            <li>Macros cannot be recursive but can be nested.</li>
            <li>Option groups can be nested.</li>
            <li>
                <code>'\'</code> (backslash) can be used to escape <code>'{'</code>, <code>'}'</code>, <code>'|'</code> and
                <code>'*'</code> special symbols used by the option groups.
            </li>
            <li>Excessive whitespaces are trimmed when expanding option groups.</li>
        </ul>
        <span id="regex" class="section-sub-title">Regular Expressions</span>
        <p>
            Any individual synonym word that starts and ends with <code>///</code> (three forward slashes) is
            considered to be Java regular expression as defined in <code>java.util.regex.Pattern</code>. Note that
            regular expression can only span a single word, i.e. only individual words from the user input will be
            matched against given regular expression and no whitespaces are allowed within regular expression. Note
            also that option group special symbols <code>{</code>, <code>}</code>,
            <code>|</code> and <code>*</code> have to be escaped in the regular expression using <code>\</code>
            (backslash).
        </p>
        <p>
            For example, the following synonym <code>{foo|///[bar].+///}}</code> will match word <code>foo</code>
            or any other strings that start with <code>bar</code> as long as this string doesn't contain whitespaces.
        </p>
        <div class="bq info">
            <b>Regular Expressions Performance</b>
            <p>
                It's important to note that regular expressions can significantly affect the performance of the
                underlying NLPCraft implementation if used uncontrolled. Use it with caution and test the performance
                of your model to ensure it meets your expectations.
            </p>
        </div>
        <span id="pos-tag" class="section-sub-title">Part-of-Speech Tags</span>
        <p>
            Any individual synonym word that that starts and ends with <code>```</code> (three back ticks) in a
            form <code>```XXX```</code> is
            considered to be a PoS (Part-of-Speech) tag that will be matched against PoS tag of the individual word in the
            user input, where <code>XXX</code> is one of the
            <a target=_ href="https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html">Penn Treebank PoS</a> tags.
        </p>
        <p>
            For example, the following synonym <code>{foo|{```NN```|```NNS```|```NNP```|```NNPS```}}</code> will
            match word <code>foo</code> or any form of a noun.
        </p>
        <span id="values" class="section-sub-title">Element Values</span>
        <p>
            Model element can have an optional set of special synonyms called <em>values</em>. Unlike basic synonyms,
            each value is a pair of a name and a set of standard synonyms by which that value, and ultimately
            its element, can be recognized in the user input. Note that the value name itself acts as an
            implicit synonym even when no additional synonyms added for that value.
        </p>
        <p>
            When a model element is recognized it is made available to the model's matching logic as an instance of
            the <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interface.
            This interface has a method
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html#getValue--">getValue()</a> which
            returns the name of the value, if any, by which
            that model element was recognized. That value name can be further used in model matching logic or intents.
        </p>
        <p>
            To understand the importance of the values consider the following example. Imagine the model
            element <code>x:car</code> that tries to describe a car. It could have:
        </p>
        <ul>
            <li>
            Set of general synonyms encoded as:
            <code>{transportation|transport|*} {vehicle|car|sedan|auto|automobile|suv|crossover|coupe|truck}</code>
            </li>
            <li>Set of values:
                <ul>
                    <li><code>mercedes</code> with synonyms <code>mercedes-benz, mb, benz</code></li>
                    <li><code>bmw</code> with synonyms <code>bimmer</code></li>
                    <li><code>chevrolet</code> with synonyms <code>chevy</code></li>
                </ul>
            </li>
        </ul>
        With that setup <code>x:car</code> element will be recognized by any of the following input string:
        <ul>
            <li><code>transport car</code></li>
            <li><code>benz</code> (with value <code>mercedes</code>)</li>
            <li><code>automobile</code></li>
            <li><code>transport vehicle</code></li>
            <li><code>sedan</code></li>
            <li><code>chevy</code> (with value <code>chevrolet</code>)</li>
            <li><code>bimmer</code> (with value <code>bmw</code>)</li>
            <li><code>x:car</code></li>
        </ul>
        <span id="groups" class="section-sub-title">Element Groups</span>
        <p>
            Each model element belongs to a certain group. By default, all model elements belong to a single
            (default) group. However, the proper organization of the elements into groups can be an important mechanism
            in implementing model's <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#query-org.nlpcraft.model.NCQueryContext-">query(NCQueryContext)</a> method.
        </p>
        <p>
            More specifically, the proper grouping of the elements is necessary for the correct operation of
            Short-Term-Memory (STM) in the conversational context when using intent-based matching.
        </p>
        <p>
            Consider a <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> that 
            represents a previously found model element that is stored in the conversation context. Such token
            will be overridden in the conversation context by the more <b>recent token</b>
            from the <b>same group</b> - a critical rule of maintaining the proper conversational context.
            In other words, the tokens (and their elements) with the same group can be overridden.
        </p>
    </section>
    <section id="metadata">
        <span class="section-title">Metadata</span>
        <p>
            Both <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> and
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interfaces have
            method <code>getMetadata()</code> that return user-defined metadata
            (a map-based container) that you can optionally attach to the data model and its elements. At runtime,
            the same metadata is available in <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> and
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCToken.html">NCToken</a> interfaces (the latter one representing a
            matched <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a>).
        </p>
        <p>
            Metadata provides flexibility to attach any user-defined information to both model and its elements
            that is not supported by default in their respective interfaces. This allows providing extra configuration
            to how the model interprets the user input and prepares the answer.
        </p>
    </section>
    <section id="config">
        <span class="section-title">Configuration</span>
    </section>
</div>
<div class="col-md-2 third-column">
    <ul class="side-nav">
        <li class="side-nav-title">On This Page</li>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#lifecycle">Lifecycle</a></li>
        <li><a href="#elements">Elements</a></li>
        <li><a href="#metadata">Metadata</a></li>
        <li><a href="#config">Configuration</a></li>
        <li class="side-nav-title">Quick Links</li>
        <li>
            <img class="quick-link-img mr-2" src="/images/github_logo.png"><a
            target="github"
            href="https://github.com/vic64/nlpcraft/tree/master/src/main/scala/org/nlpcraft/examples">Examples</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/java.png"><a
            target="javadoc"
            href="/apis/latest/index.html">Javadoc</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/apiary.svg"><a
            href="https://nlpcraft.docs.apiary.io"
            target="apiary">REST API</a>
        </li>
        <li>
            <i class="fas fa-download mr-2"></i><a href="/download">Download</a>
        </li>
        <li class="side-nav-title">Support</li>
        <li>
            <nobr>
                <i class="far fa-fw fa-envelope mr-2"></i><a href="mailto:support@nlpcraft.org">Email</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-stack-overflow mr-2"></i><a target="so" href="https://stackoverflow.com/questions/ask">Stack Overflow</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-github mr-2"></i><a target="github" href="https://github.com/vic64/nlpcraft/issues">GitHub</a>
            </nobr>
        </li>
    </ul>
</div>




