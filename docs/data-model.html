---
active_crumb: Data Model API
layout: documentation
---

<!--
   “Commons Clause” License, https://commonsclause.com/

   The Software is provided to you by the Licensor under the License,
   as defined below, subject to the following condition.

   Without limiting other conditions in the License, the grant of rights
   under the License will not include, and the License does not grant to
   you, the right to Sell the Software.

   For purposes of the foregoing, “Sell” means practicing any or all of
   the rights granted to you under the License to provide to third parties,
   for a fee or other consideration (including without limitation fees for
   hosting or consulting/support services related to the Software), a
   product or service whose value derives, entirely or substantially, from
   the functionality of the Software. Any license notice or attribution
   required by the License must also include this Commons Clause License
   Condition notice.

   Software:    NLPCraft
   License:     Apache 2.0, https://www.apache.org/licenses/LICENSE-2.0
   Licensor:    Copyright (C) 2018 DataLingvo, Inc. https://www.datalingvo.com

       _   ____      ______           ______
      / | / / /___  / ____/________ _/ __/ /_
     /  |/ / / __ \/ /   / ___/ __ `/ /_/ __/
    / /|  / / /_/ / /___/ /  / /_/ / __/ /_
   /_/ |_/_/ .___/\____/_/   \__,_/_/  \__/
          /_/
-->

<div class="col-md-8 second-column">
    <section>
        <span class="section-title">Data Model Overview</span>
        <p>
            NLPCraft employs model-as-a-code approach where data model is simply an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> Java interface that can be developed using any JVM programming
            language like Java, Scala, Kotlin, or Groovy. Data model implementation defines:
        </p>
        <ul>
            <li>
                How to interpret user input
            </li>
            <li>
                How to query or control a particular data source
            </li>
            <li>
                How to format the result back to the user
            </li>
        </ul>
        <p>
            Note that model-as-a-code approach natively supports any software life
            cycle tools and frameworks in Java eco-system like various build tools, CI/SCM tools, IDEs, etc.
            In other words, you don't have to use awkward web-based tools to manage some aspects of your
            models - your entire model is part of your project source code.
        </p>
    </section>
    <section>
        <span class="section-title">Data Model Lifecycle</span>
        <p>
            To deploy a data model you need to provide an implementation of
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> - a simple
            interface that acts as a factory or a builder for one or more
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> instances. This separation is
            important as it enables data probes to query data model provider about which models it supports
            without necessarily instantiating an actual data model which could be expensive, not idempotent
            and time-consuming operation.
        </p>
        <div class="bq info">
            <b>NCModelProviderAdapter</b>
            <p>
                Note that instead of implementing
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                directly in most cases you can use a
                convenient
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProviderAdapter.html">NCModelProviderAdapter</a> adapter class.
            </p>
        </div>
        <p>
            As described before the data models get <a href="/deploying-data-model.html">deployed</a> to and hosted by the data probes - a lightweight
            container whose job is to host data models and transfer requests between REST server and the data
            models. When a data probe starts it reads its configuration file <code>probe.conf</code> to see which models to
            deploy:
        </p>
        <ul>
            <li>
                If property <code>modelProviders</code> is defined the data probe will try to deploy all models
                this property defines by their fully qualified class names.
            </li>
            <li>
                If property <code>jarsFolder</code> is defined the data probe will recursively scan for all JAR files in this
                folder and will try to find all implementations of
                <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModelProvider.html">NCModelProvider</a> interface
                and deploy their data models.
            </li>
        </ul>
        <p>
            Note that once deployed the data model is immutable. If you need to change the data model
            configuration or implementation, as in the development and testing phases,  you need to restart the
            probe to redeploy this data model.
        </p>
        <span class="section-sub-title">Lifecycle Events</span>
        <p>
            There are two data model lifecycle callbacks on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface
            that you can optionally override:
        </p>
        <ul>
            <li><code>initialize(NCProbeContext)</code> - called to initialize the model when it gets deployed.</li>
            <li><code>discard()</code> - called to discard the data model when data probe is shutting down.</li>
        </ul>
    </section>
    <section>
        <span class="section-title">Data Model Elements</span>
        <p>
            One of the most important parts of developing a data model is defining its elements. A data model
            element is the main building block of the semantic data model. A semantic element defines an entity
            that will be automatically recognized as a token in the user input either by one of its synonyms or values or
            directly by its ID. These tokens in turn will be used by the data model in its matching logic.
        </p>
        <p>
            Data model element is defined by <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a>
            interface:
        </p>
        <pre class="brush: java">
            public interface NCElement {
                interface NCValue {
                    String getName();
                    List&lt;String&gt; getSynonyms();
                }

                String getId();
                String getGroup();
                NCMetadata getMetadata();
                String getDescription();
                List&lt;NCValue&gt; getValues();
                String getParentId();
                List&lt;String&gt; getSynonyms();
                List&lt;String&gt; getExcludedSynonyms();
            }

        </pre>
        <p>
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> returns
            its elements via <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getElements--">getElements()</a> method. To create model element
            you can either:
        </p>
        <ul>
            <li>
                Implement <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> interface directly, or
            </li>
            <li>
                Use <a target="javadoc" href="/apis/latest/org/nlpcraft/model/builder/NCElementBuilder.html">NCElementBuilder</a>
                builder class if element definition is constructed dynamically, or
            </li>
            <li>
                Use JSON or YAML static model configuration (the preferred way in most cases).
            </li>
        </ul>
        <p>
            When defining the elements the synonyms play the most critical role. It is the synonyms that define
            how a particular element will be detected in the user input. While adding synonyms sounds rather
            trivial - in real models, this may become a daunting and time-consuming task. It is not uncommon
            for a particular model element to have thousands and even tens of thousands of possible synonyms
            due to words, grammar, and linguistic permutations.
        </p>
        <p>
            NLPCraft provides effective support for a compact synonyms representation. Instead of listing all possible
            multi-word synonyms one by one you can use macros, option groups, regular expressions, and PoS tags to
            significantly shorten that list.
        </p>
        <span class="section-sub-title">Synonyms</span>
        <p>
            Synonyms are the key building blocks of the data model element and used in the following
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCElement.html">NCElement</a> methods:
        </p>
        <ul>
            <li><code>getSynonyms()</code> - gets synonyms to match on.</li>
            <li><code>getExcludedSynonyms()</code> - gets synonyms to exclude.</li>
            <li><code>getValues()</code> - get values to match on.</li>
        </ul>
        <p>
            Each data model element has one or more synonyms. Note that element ID is its implicit synonym so that
            even if no additional synonyms are defined at least one synonym always exists. Each individual synonym
            is a whitespace separated combination of:
        </p>
        <ul>
           <li>simple word,</li>
           <li>regular expression, or</li>
           <li>PoS tag</li>
        </ul>
        <p>
            Note that synonym matching for simple words is case insensitive and automatically
            performed on <b>normalized and stemmatized forms</b> of such word and therefore the model
            developer doesn't have to account for this in the synonyms themselves.
        </p>
        <span class="section-sub-title">Macros</span>
        <p>
            Listing all possible multi-word synonyms for a given element can be a time-consuming task. Macros
            together with option groups allow for significant simplification of this process.
            Macros let you give a name to an often used set of words or option groups and reuse it without
            repeating those words or option groups again and again. A model provides a list of macros via
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html#getMacros--">getMacros()</a> method on
            <a target="javadoc" href="/apis/latest/org/nlpcraft/model/NCModel.html">NCModel</a> interface. Each macro
            has a name in a form of <code>&lt;X&gt;</code> where <code>X</code>
            is just any string, and a string value. Note that macros can be nested, i.e. macro value can include
            references to other macros. When macro name <code>X</code> is encountered in the synonym it gets recursively
            replaced with its value.
        </p>
        <p>
            Here's a code snippet of macro definitions using JSON configuration:
        </p>
        <pre class="brush: js">
            "macros": [
                {
                    "name": "&lt;A&gt;",
                    "macro": "aaa"
                },
                {
                    "name": "&lt;B&gt;",
                    "macro": "&lt;A&gt; bbb"
                },
                {
                    "name": "&lt;C&gt;",
                    "macro": "&lt;A&gt; bbb {z|w}"
                }
             ]
        </pre>
<!--







            *
           <h3>Option Groups</h3>
           Option groups are a simplified form of regular expressions that operates on a single word base. The
           following examples demonstrate how to use option groups. Consider that the following macros are defined:
           <table summary="" class="dl-table">
                   <tr>
                       <th>Macro Name</th>
                       <th>Macro Value</th>
                   </tr>
                   <tr>
                       <td>{@code &lt;A&gt;}</td>
                       <td>{@code aaa}</td>
                   </tr>
                   <tr>
                       <td>{@code &lt;B&gt;}</td>
                       <td>{@code &lt;A&gt; bbb}</td>
                   </tr>
                   <tr>
                       <td>{@code &lt;C&gt;}</td>
                       <td>{@code &lt;A&gt; bbb {z|w}}</td>
                   </tr>
               </table>
           Note that macros {@code &lt;B&gt;} and {@code &lt;C&gt;} are nested. Then the following option group expansions
               will occur in these examples:
               <table summary="" class="dl-table">
                       <tr>
                           <th>Synonym</th>
                           <th>Expanded Synonyms</th>
                       </tr>
                       <tr>
                           <td>{@code &lt;A&gt; {b|*} c}</td>
                           <td>
                               {@code "aaa b c"}<br>
                               {@code "aaa c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code &lt;B&gt; {b|*} c}</td>
                           <td>
                               {@code "aaa bbb b c"}<br>
                                {@code "aaa bbb c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code {b|```NN```} c}</td>
                           <td>
                               {@code "b c"}<br>
                               {@code "```NN``` c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code {b|\{\*\}}}</td>
                           <td>
                               {@code "b"}<br>
                               {@code "b {*}"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code a {b|*}. c}</td>
                           <td>
                               {@code "a b. c"}<br>
                               {@code "a . c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code a .{b,  |*}. c}</td>
                           <td>
                               {@code "a .b, . c"}<br>
                               {@code "a .. c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code a \{\{b|c}|*}.}</td>
                           <td>
                               {@code "a ."}<br>
                               {@code "a b."}<br>
                               {@code "a c."}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code a \{\{{&lt;C&gt;}}|{*}} c}</td>
                           <td>
                               {@code "a aaa bbb z c"}<br>
                               {@code "a aaa bbb w c"}<br>
                               {@code "a c"}
                           </td>
                       </tr>
                       <tr>
                           <td>{@code \{\{{a}}} {b||*|\{\{*}}||*}}</td>
                           <td>
                               {@code "a b"}<br>
                               {@code "a"}
                           </td>
                       </tr>
                   </table>
               Specifically:
               <ul>
                       <li>{@code {A|B}}  denotes either {@code A} or {@code B}.</li>
                       <li>{@code {A|B|*}}  denotes either {@code A} or {@code B} or nothing.</li>
                       <li>Excessive curly brackets are ignored, when safe to do so.</li>
                       <li>Macros cannot be recursive but can be nested.</li>
                       <li>Option groups can be nested.</li>
                       <li>
                           {@code '\'} (backslash) can be used to escape <code>'{'</code>, <code>'}'</code>, {@code '|'} and
                           {@code '*'} special symbols used by the option groups.
                       </li>
                       <li>Excessive whitespaces are trimmed when expanding option groups.</li>
                   </ul>
                *
               <h3>Regular Expressions</h3>
               Any individual synonym word that starts and ends with {@code "///"} (three forward slashes) is considered to be Java
               regular expression as defined in {@link Pattern}. Note that regular expression can only span a single word, i.e.
               only individual words from the user input will be matched against given regular expression and no whitespaces are
               allowed within regular expression. Note also that option group special symbols <code>'{'</code>, <code>'}'</code>,
               {@code '|'} and {@code '*'} have to be escaped in the regular expression using {@code '\'} (backslash).
               <br><br>
               For example, the following synonym {@code {foo|///[bar].+///}} will match word {@code foo} or any other strings
               that start with {@code bar} as long as this string doesn't contain whitespaces.
                *
               <h3>PoS Tags</h3>
               Any individual synonym word that that starts and ends with {@code "```"} (three back ticks) in a form <code>```XXX```</code> is
               considered to be a PoS (Part-of-Speech) tag that will be matched against PoS tag of the individual word in the
               user input, where {@code XXX} is one of the
               <a target=_ href="https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html">Penn Treebank PoS</a> tags.
               <br><br>
               For example, the following synonym <code>{foo|{```NN```|```NNS```|```NNP```|```NNPS```}}</code> will match word {@code foo} or any
               form of a noun.
                   -->
    </section>
</div>
<div class="col-md-2 third-column">
    <ul class="side-nav">
        <li class="side-nav-title">On This Page</li>
        <li class="side-nav-title">Quick Links</li>
        <li>
            <img class="quick-link-img mr-2" src="/images/github_logo.png"><a
            target="github"
            href="https://github.com/vic64/nlpcraft/tree/master/src/main/scala/org/nlpcraft/examples">Examples</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/java.png"><a
            target="javadoc"
            href="/apis/latest/index.html">Javadoc</a>
        </li>
        <li>
            <img class="quick-link-img mr-2" src="/images/apiary.svg"><a
            href="https://nlpcraft.docs.apiary.io"
            target="apiary">REST API</a>
        </li>
        <li>
            <i class="fas fa-download mr-2"></i><a href="/download">Download</a>
        </li>
        <li class="side-nav-title">Support</li>
        <li>
            <nobr>
                <i class="far fa-fw fa-envelope mr-2"></i><a href="mailto:support@nlpcraft.org">Email</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-stack-overflow mr-2"></i><a target="so" href="https://stackoverflow.com/questions/ask">Stack Overflow</a>
            </nobr>
        </li>
        <li>
            <nobr>
                <i class="fab fa-fw fa-github mr-2"></i><a target="github" href="https://github.com/vic64/nlpcraft/issues">GitHub</a>
            </nobr>
        </li>
    </ul>
</div>




